// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"persona/libs/database/ent/assignmentschema"
	"persona/libs/database/ent/namecardschema"
	"persona/libs/database/ent/personalizationschema"
	"persona/libs/database/ent/phoneschema"
	"persona/libs/database/ent/photoschema"
	"persona/libs/database/ent/predicate"
	"persona/libs/database/ent/profileschema"
	"persona/libs/database/ent/referrerschema"
	"persona/libs/database/ent/roleschema"
	"persona/libs/database/ent/userschema"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplicationSchema     = "ApplicationSchema"
	TypeAssignmentSchema      = "AssignmentSchema"
	TypeBadgeSchema           = "BadgeSchema"
	TypeBookmarkSchema        = "BookmarkSchema"
	TypeCommentSchema         = "CommentSchema"
	TypeCompanySchema         = "CompanySchema"
	TypeCoverLetterSchema     = "CoverLetterSchema"
	TypeExperienceSchema      = "ExperienceSchema"
	TypeFollowSchema          = "FollowSchema"
	TypeImageSchema           = "ImageSchema"
	TypeJobSchema             = "JobSchema"
	TypeLeetcodeSchema        = "LeetcodeSchema"
	TypeLikeSchema            = "LikeSchema"
	TypeLocationSchema        = "LocationSchema"
	TypeLogoSchema            = "LogoSchema"
	TypeNamecardSchema        = "NamecardSchema"
	TypeNotificationSchema    = "NotificationSchema"
	TypePaymentSchema         = "PaymentSchema"
	TypePersonalizationSchema = "PersonalizationSchema"
	TypePhoneSchema           = "PhoneSchema"
	TypePhotoSchema           = "PhotoSchema"
	TypePoolSchema            = "PoolSchema"
	TypePortfolioSchema       = "PortfolioSchema"
	TypePositionSchema        = "PositionSchema"
	TypeProfileSchema         = "ProfileSchema"
	TypeReferrerSchema        = "ReferrerSchema"
	TypeResumeSchema          = "ResumeSchema"
	TypeRoleSchema            = "RoleSchema"
	TypeSkillSchema           = "SkillSchema"
	TypeSubscribeSchema       = "SubscribeSchema"
	TypeThreadSchema          = "ThreadSchema"
	TypeUserSchema            = "UserSchema"
)

// ApplicationSchemaMutation represents an operation that mutates the ApplicationSchema nodes in the graph.
type ApplicationSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ApplicationSchema, error)
	predicates    []predicate.ApplicationSchema
}

var _ ent.Mutation = (*ApplicationSchemaMutation)(nil)

// applicationschemaOption allows management of the mutation configuration using functional options.
type applicationschemaOption func(*ApplicationSchemaMutation)

// newApplicationSchemaMutation creates new mutation for the ApplicationSchema entity.
func newApplicationSchemaMutation(c config, op Op, opts ...applicationschemaOption) *ApplicationSchemaMutation {
	m := &ApplicationSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeApplicationSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationSchemaID sets the ID field of the mutation.
func withApplicationSchemaID(id int) applicationschemaOption {
	return func(m *ApplicationSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *ApplicationSchema
		)
		m.oldValue = func(ctx context.Context) (*ApplicationSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApplicationSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplicationSchema sets the old ApplicationSchema of the mutation.
func withApplicationSchema(node *ApplicationSchema) applicationschemaOption {
	return func(m *ApplicationSchemaMutation) {
		m.oldValue = func(context.Context) (*ApplicationSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApplicationSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ApplicationSchemaMutation builder.
func (m *ApplicationSchemaMutation) Where(ps ...predicate.ApplicationSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApplicationSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApplicationSchema).
func (m *ApplicationSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ApplicationSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApplicationSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ApplicationSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApplicationSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ApplicationSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApplicationSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApplicationSchema edge %s", name)
}

// AssignmentSchemaMutation represents an operation that mutates the AssignmentSchema nodes in the graph.
type AssignmentSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	_type         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AssignmentSchema, error)
	predicates    []predicate.AssignmentSchema
}

var _ ent.Mutation = (*AssignmentSchemaMutation)(nil)

// assignmentschemaOption allows management of the mutation configuration using functional options.
type assignmentschemaOption func(*AssignmentSchemaMutation)

// newAssignmentSchemaMutation creates new mutation for the AssignmentSchema entity.
func newAssignmentSchemaMutation(c config, op Op, opts ...assignmentschemaOption) *AssignmentSchemaMutation {
	m := &AssignmentSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeAssignmentSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssignmentSchemaID sets the ID field of the mutation.
func withAssignmentSchemaID(id int) assignmentschemaOption {
	return func(m *AssignmentSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *AssignmentSchema
		)
		m.oldValue = func(ctx context.Context) (*AssignmentSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssignmentSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssignmentSchema sets the old AssignmentSchema of the mutation.
func withAssignmentSchema(node *AssignmentSchema) assignmentschemaOption {
	return func(m *AssignmentSchemaMutation) {
		m.oldValue = func(context.Context) (*AssignmentSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssignmentSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssignmentSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssignmentSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssignmentSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssignmentSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AssignmentSchemaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssignmentSchemaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AssignmentSchema entity.
// If the AssignmentSchema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSchemaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssignmentSchemaMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AssignmentSchemaMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AssignmentSchemaMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AssignmentSchema entity.
// If the AssignmentSchema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSchemaMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AssignmentSchemaMutation) ResetType() {
	m._type = nil
}

// Where appends a list predicates to the AssignmentSchemaMutation builder.
func (m *AssignmentSchemaMutation) Where(ps ...predicate.AssignmentSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssignmentSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssignmentSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssignmentSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssignmentSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssignmentSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssignmentSchema).
func (m *AssignmentSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssignmentSchemaMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, assignmentschema.FieldName)
	}
	if m._type != nil {
		fields = append(fields, assignmentschema.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssignmentSchemaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assignmentschema.FieldName:
		return m.Name()
	case assignmentschema.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssignmentSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assignmentschema.FieldName:
		return m.OldName(ctx)
	case assignmentschema.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown AssignmentSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assignmentschema.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case assignmentschema.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown AssignmentSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssignmentSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssignmentSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentSchemaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssignmentSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssignmentSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssignmentSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssignmentSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AssignmentSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssignmentSchemaMutation) ResetField(name string) error {
	switch name {
	case assignmentschema.FieldName:
		m.ResetName()
		return nil
	case assignmentschema.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssignmentSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssignmentSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssignmentSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssignmentSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssignmentSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssignmentSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssignmentSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AssignmentSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssignmentSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AssignmentSchema edge %s", name)
}

// BadgeSchemaMutation represents an operation that mutates the BadgeSchema nodes in the graph.
type BadgeSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BadgeSchema, error)
	predicates    []predicate.BadgeSchema
}

var _ ent.Mutation = (*BadgeSchemaMutation)(nil)

// badgeschemaOption allows management of the mutation configuration using functional options.
type badgeschemaOption func(*BadgeSchemaMutation)

// newBadgeSchemaMutation creates new mutation for the BadgeSchema entity.
func newBadgeSchemaMutation(c config, op Op, opts ...badgeschemaOption) *BadgeSchemaMutation {
	m := &BadgeSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeBadgeSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBadgeSchemaID sets the ID field of the mutation.
func withBadgeSchemaID(id int) badgeschemaOption {
	return func(m *BadgeSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *BadgeSchema
		)
		m.oldValue = func(ctx context.Context) (*BadgeSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BadgeSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBadgeSchema sets the old BadgeSchema of the mutation.
func withBadgeSchema(node *BadgeSchema) badgeschemaOption {
	return func(m *BadgeSchemaMutation) {
		m.oldValue = func(context.Context) (*BadgeSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BadgeSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BadgeSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BadgeSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BadgeSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BadgeSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the BadgeSchemaMutation builder.
func (m *BadgeSchemaMutation) Where(ps ...predicate.BadgeSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BadgeSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BadgeSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BadgeSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BadgeSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BadgeSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BadgeSchema).
func (m *BadgeSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BadgeSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BadgeSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BadgeSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown BadgeSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BadgeSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BadgeSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BadgeSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown BadgeSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BadgeSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BadgeSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BadgeSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BadgeSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BadgeSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown BadgeSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BadgeSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BadgeSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BadgeSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BadgeSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BadgeSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BadgeSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BadgeSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BadgeSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BadgeSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BadgeSchema edge %s", name)
}

// BookmarkSchemaMutation represents an operation that mutates the BookmarkSchema nodes in the graph.
type BookmarkSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BookmarkSchema, error)
	predicates    []predicate.BookmarkSchema
}

var _ ent.Mutation = (*BookmarkSchemaMutation)(nil)

// bookmarkschemaOption allows management of the mutation configuration using functional options.
type bookmarkschemaOption func(*BookmarkSchemaMutation)

// newBookmarkSchemaMutation creates new mutation for the BookmarkSchema entity.
func newBookmarkSchemaMutation(c config, op Op, opts ...bookmarkschemaOption) *BookmarkSchemaMutation {
	m := &BookmarkSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeBookmarkSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookmarkSchemaID sets the ID field of the mutation.
func withBookmarkSchemaID(id int) bookmarkschemaOption {
	return func(m *BookmarkSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *BookmarkSchema
		)
		m.oldValue = func(ctx context.Context) (*BookmarkSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookmarkSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookmarkSchema sets the old BookmarkSchema of the mutation.
func withBookmarkSchema(node *BookmarkSchema) bookmarkschemaOption {
	return func(m *BookmarkSchemaMutation) {
		m.oldValue = func(context.Context) (*BookmarkSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookmarkSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookmarkSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookmarkSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookmarkSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookmarkSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the BookmarkSchemaMutation builder.
func (m *BookmarkSchemaMutation) Where(ps ...predicate.BookmarkSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookmarkSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookmarkSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookmarkSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookmarkSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookmarkSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookmarkSchema).
func (m *BookmarkSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookmarkSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookmarkSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookmarkSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown BookmarkSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookmarkSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BookmarkSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookmarkSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookmarkSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookmarkSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown BookmarkSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookmarkSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookmarkSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookmarkSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BookmarkSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookmarkSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown BookmarkSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookmarkSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookmarkSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookmarkSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookmarkSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookmarkSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookmarkSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookmarkSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookmarkSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookmarkSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookmarkSchema edge %s", name)
}

// CommentSchemaMutation represents an operation that mutates the CommentSchema nodes in the graph.
type CommentSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CommentSchema, error)
	predicates    []predicate.CommentSchema
}

var _ ent.Mutation = (*CommentSchemaMutation)(nil)

// commentschemaOption allows management of the mutation configuration using functional options.
type commentschemaOption func(*CommentSchemaMutation)

// newCommentSchemaMutation creates new mutation for the CommentSchema entity.
func newCommentSchemaMutation(c config, op Op, opts ...commentschemaOption) *CommentSchemaMutation {
	m := &CommentSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentSchemaID sets the ID field of the mutation.
func withCommentSchemaID(id int) commentschemaOption {
	return func(m *CommentSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentSchema
		)
		m.oldValue = func(ctx context.Context) (*CommentSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentSchema sets the old CommentSchema of the mutation.
func withCommentSchema(node *CommentSchema) commentschemaOption {
	return func(m *CommentSchemaMutation) {
		m.oldValue = func(context.Context) (*CommentSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommentSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the CommentSchemaMutation builder.
func (m *CommentSchemaMutation) Where(ps ...predicate.CommentSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommentSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommentSchema).
func (m *CommentSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CommentSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CommentSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CommentSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CommentSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CommentSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommentSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommentSchema edge %s", name)
}

// CompanySchemaMutation represents an operation that mutates the CompanySchema nodes in the graph.
type CompanySchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CompanySchema, error)
	predicates    []predicate.CompanySchema
}

var _ ent.Mutation = (*CompanySchemaMutation)(nil)

// companyschemaOption allows management of the mutation configuration using functional options.
type companyschemaOption func(*CompanySchemaMutation)

// newCompanySchemaMutation creates new mutation for the CompanySchema entity.
func newCompanySchemaMutation(c config, op Op, opts ...companyschemaOption) *CompanySchemaMutation {
	m := &CompanySchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanySchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanySchemaID sets the ID field of the mutation.
func withCompanySchemaID(id int) companyschemaOption {
	return func(m *CompanySchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanySchema
		)
		m.oldValue = func(ctx context.Context) (*CompanySchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanySchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanySchema sets the old CompanySchema of the mutation.
func withCompanySchema(node *CompanySchema) companyschemaOption {
	return func(m *CompanySchemaMutation) {
		m.oldValue = func(context.Context) (*CompanySchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanySchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanySchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanySchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanySchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanySchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the CompanySchemaMutation builder.
func (m *CompanySchemaMutation) Where(ps ...predicate.CompanySchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanySchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanySchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanySchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanySchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanySchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanySchema).
func (m *CompanySchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanySchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanySchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanySchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CompanySchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanySchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CompanySchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanySchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanySchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanySchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CompanySchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanySchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanySchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanySchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CompanySchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanySchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CompanySchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanySchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanySchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanySchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanySchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanySchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanySchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanySchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CompanySchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanySchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CompanySchema edge %s", name)
}

// CoverLetterSchemaMutation represents an operation that mutates the CoverLetterSchema nodes in the graph.
type CoverLetterSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CoverLetterSchema, error)
	predicates    []predicate.CoverLetterSchema
}

var _ ent.Mutation = (*CoverLetterSchemaMutation)(nil)

// coverletterschemaOption allows management of the mutation configuration using functional options.
type coverletterschemaOption func(*CoverLetterSchemaMutation)

// newCoverLetterSchemaMutation creates new mutation for the CoverLetterSchema entity.
func newCoverLetterSchemaMutation(c config, op Op, opts ...coverletterschemaOption) *CoverLetterSchemaMutation {
	m := &CoverLetterSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeCoverLetterSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoverLetterSchemaID sets the ID field of the mutation.
func withCoverLetterSchemaID(id int) coverletterschemaOption {
	return func(m *CoverLetterSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *CoverLetterSchema
		)
		m.oldValue = func(ctx context.Context) (*CoverLetterSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CoverLetterSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoverLetterSchema sets the old CoverLetterSchema of the mutation.
func withCoverLetterSchema(node *CoverLetterSchema) coverletterschemaOption {
	return func(m *CoverLetterSchemaMutation) {
		m.oldValue = func(context.Context) (*CoverLetterSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoverLetterSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoverLetterSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CoverLetterSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CoverLetterSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CoverLetterSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the CoverLetterSchemaMutation builder.
func (m *CoverLetterSchemaMutation) Where(ps ...predicate.CoverLetterSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CoverLetterSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CoverLetterSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CoverLetterSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CoverLetterSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CoverLetterSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CoverLetterSchema).
func (m *CoverLetterSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CoverLetterSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CoverLetterSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CoverLetterSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CoverLetterSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoverLetterSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CoverLetterSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CoverLetterSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CoverLetterSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoverLetterSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CoverLetterSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CoverLetterSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CoverLetterSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoverLetterSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CoverLetterSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CoverLetterSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CoverLetterSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CoverLetterSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CoverLetterSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CoverLetterSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CoverLetterSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CoverLetterSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CoverLetterSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CoverLetterSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CoverLetterSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CoverLetterSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CoverLetterSchema edge %s", name)
}

// ExperienceSchemaMutation represents an operation that mutates the ExperienceSchema nodes in the graph.
type ExperienceSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ExperienceSchema, error)
	predicates    []predicate.ExperienceSchema
}

var _ ent.Mutation = (*ExperienceSchemaMutation)(nil)

// experienceschemaOption allows management of the mutation configuration using functional options.
type experienceschemaOption func(*ExperienceSchemaMutation)

// newExperienceSchemaMutation creates new mutation for the ExperienceSchema entity.
func newExperienceSchemaMutation(c config, op Op, opts ...experienceschemaOption) *ExperienceSchemaMutation {
	m := &ExperienceSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeExperienceSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExperienceSchemaID sets the ID field of the mutation.
func withExperienceSchemaID(id int) experienceschemaOption {
	return func(m *ExperienceSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *ExperienceSchema
		)
		m.oldValue = func(ctx context.Context) (*ExperienceSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExperienceSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExperienceSchema sets the old ExperienceSchema of the mutation.
func withExperienceSchema(node *ExperienceSchema) experienceschemaOption {
	return func(m *ExperienceSchemaMutation) {
		m.oldValue = func(context.Context) (*ExperienceSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExperienceSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExperienceSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExperienceSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExperienceSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExperienceSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ExperienceSchemaMutation builder.
func (m *ExperienceSchemaMutation) Where(ps ...predicate.ExperienceSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExperienceSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExperienceSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExperienceSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExperienceSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExperienceSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExperienceSchema).
func (m *ExperienceSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExperienceSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExperienceSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExperienceSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ExperienceSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ExperienceSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExperienceSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExperienceSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ExperienceSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExperienceSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExperienceSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExperienceSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ExperienceSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExperienceSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ExperienceSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExperienceSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExperienceSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExperienceSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExperienceSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExperienceSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExperienceSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExperienceSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExperienceSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExperienceSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExperienceSchema edge %s", name)
}

// FollowSchemaMutation represents an operation that mutates the FollowSchema nodes in the graph.
type FollowSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FollowSchema, error)
	predicates    []predicate.FollowSchema
}

var _ ent.Mutation = (*FollowSchemaMutation)(nil)

// followschemaOption allows management of the mutation configuration using functional options.
type followschemaOption func(*FollowSchemaMutation)

// newFollowSchemaMutation creates new mutation for the FollowSchema entity.
func newFollowSchemaMutation(c config, op Op, opts ...followschemaOption) *FollowSchemaMutation {
	m := &FollowSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeFollowSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFollowSchemaID sets the ID field of the mutation.
func withFollowSchemaID(id int) followschemaOption {
	return func(m *FollowSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *FollowSchema
		)
		m.oldValue = func(ctx context.Context) (*FollowSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FollowSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFollowSchema sets the old FollowSchema of the mutation.
func withFollowSchema(node *FollowSchema) followschemaOption {
	return func(m *FollowSchemaMutation) {
		m.oldValue = func(context.Context) (*FollowSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FollowSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FollowSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FollowSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FollowSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FollowSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the FollowSchemaMutation builder.
func (m *FollowSchemaMutation) Where(ps ...predicate.FollowSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FollowSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FollowSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FollowSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FollowSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FollowSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FollowSchema).
func (m *FollowSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FollowSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FollowSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FollowSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown FollowSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FollowSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FollowSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FollowSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown FollowSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FollowSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FollowSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FollowSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FollowSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FollowSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown FollowSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FollowSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FollowSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FollowSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FollowSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FollowSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FollowSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FollowSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FollowSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FollowSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FollowSchema edge %s", name)
}

// ImageSchemaMutation represents an operation that mutates the ImageSchema nodes in the graph.
type ImageSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ImageSchema, error)
	predicates    []predicate.ImageSchema
}

var _ ent.Mutation = (*ImageSchemaMutation)(nil)

// imageschemaOption allows management of the mutation configuration using functional options.
type imageschemaOption func(*ImageSchemaMutation)

// newImageSchemaMutation creates new mutation for the ImageSchema entity.
func newImageSchemaMutation(c config, op Op, opts ...imageschemaOption) *ImageSchemaMutation {
	m := &ImageSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeImageSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageSchemaID sets the ID field of the mutation.
func withImageSchemaID(id int) imageschemaOption {
	return func(m *ImageSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *ImageSchema
		)
		m.oldValue = func(ctx context.Context) (*ImageSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImageSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImageSchema sets the old ImageSchema of the mutation.
func withImageSchema(node *ImageSchema) imageschemaOption {
	return func(m *ImageSchemaMutation) {
		m.oldValue = func(context.Context) (*ImageSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImageSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ImageSchemaMutation builder.
func (m *ImageSchemaMutation) Where(ps ...predicate.ImageSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImageSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImageSchema).
func (m *ImageSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ImageSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImageSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ImageSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ImageSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ImageSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ImageSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ImageSchema edge %s", name)
}

// JobSchemaMutation represents an operation that mutates the JobSchema nodes in the graph.
type JobSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*JobSchema, error)
	predicates    []predicate.JobSchema
}

var _ ent.Mutation = (*JobSchemaMutation)(nil)

// jobschemaOption allows management of the mutation configuration using functional options.
type jobschemaOption func(*JobSchemaMutation)

// newJobSchemaMutation creates new mutation for the JobSchema entity.
func newJobSchemaMutation(c config, op Op, opts ...jobschemaOption) *JobSchemaMutation {
	m := &JobSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeJobSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobSchemaID sets the ID field of the mutation.
func withJobSchemaID(id int) jobschemaOption {
	return func(m *JobSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *JobSchema
		)
		m.oldValue = func(ctx context.Context) (*JobSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobSchema sets the old JobSchema of the mutation.
func withJobSchema(node *JobSchema) jobschemaOption {
	return func(m *JobSchemaMutation) {
		m.oldValue = func(context.Context) (*JobSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the JobSchemaMutation builder.
func (m *JobSchemaMutation) Where(ps ...predicate.JobSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobSchema).
func (m *JobSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown JobSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown JobSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JobSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown JobSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown JobSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown JobSchema edge %s", name)
}

// LeetcodeSchemaMutation represents an operation that mutates the LeetcodeSchema nodes in the graph.
type LeetcodeSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LeetcodeSchema, error)
	predicates    []predicate.LeetcodeSchema
}

var _ ent.Mutation = (*LeetcodeSchemaMutation)(nil)

// leetcodeschemaOption allows management of the mutation configuration using functional options.
type leetcodeschemaOption func(*LeetcodeSchemaMutation)

// newLeetcodeSchemaMutation creates new mutation for the LeetcodeSchema entity.
func newLeetcodeSchemaMutation(c config, op Op, opts ...leetcodeschemaOption) *LeetcodeSchemaMutation {
	m := &LeetcodeSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeLeetcodeSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeetcodeSchemaID sets the ID field of the mutation.
func withLeetcodeSchemaID(id int) leetcodeschemaOption {
	return func(m *LeetcodeSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *LeetcodeSchema
		)
		m.oldValue = func(ctx context.Context) (*LeetcodeSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LeetcodeSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeetcodeSchema sets the old LeetcodeSchema of the mutation.
func withLeetcodeSchema(node *LeetcodeSchema) leetcodeschemaOption {
	return func(m *LeetcodeSchemaMutation) {
		m.oldValue = func(context.Context) (*LeetcodeSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeetcodeSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeetcodeSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeetcodeSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeetcodeSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LeetcodeSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the LeetcodeSchemaMutation builder.
func (m *LeetcodeSchemaMutation) Where(ps ...predicate.LeetcodeSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeetcodeSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeetcodeSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LeetcodeSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeetcodeSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeetcodeSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LeetcodeSchema).
func (m *LeetcodeSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeetcodeSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeetcodeSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeetcodeSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown LeetcodeSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeetcodeSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LeetcodeSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeetcodeSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeetcodeSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeetcodeSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown LeetcodeSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeetcodeSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeetcodeSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeetcodeSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LeetcodeSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeetcodeSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown LeetcodeSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeetcodeSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeetcodeSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeetcodeSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeetcodeSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeetcodeSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeetcodeSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeetcodeSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LeetcodeSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeetcodeSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LeetcodeSchema edge %s", name)
}

// LikeSchemaMutation represents an operation that mutates the LikeSchema nodes in the graph.
type LikeSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LikeSchema, error)
	predicates    []predicate.LikeSchema
}

var _ ent.Mutation = (*LikeSchemaMutation)(nil)

// likeschemaOption allows management of the mutation configuration using functional options.
type likeschemaOption func(*LikeSchemaMutation)

// newLikeSchemaMutation creates new mutation for the LikeSchema entity.
func newLikeSchemaMutation(c config, op Op, opts ...likeschemaOption) *LikeSchemaMutation {
	m := &LikeSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeLikeSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikeSchemaID sets the ID field of the mutation.
func withLikeSchemaID(id int) likeschemaOption {
	return func(m *LikeSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *LikeSchema
		)
		m.oldValue = func(ctx context.Context) (*LikeSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LikeSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLikeSchema sets the old LikeSchema of the mutation.
func withLikeSchema(node *LikeSchema) likeschemaOption {
	return func(m *LikeSchemaMutation) {
		m.oldValue = func(context.Context) (*LikeSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikeSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikeSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikeSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikeSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LikeSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the LikeSchemaMutation builder.
func (m *LikeSchemaMutation) Where(ps ...predicate.LikeSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LikeSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LikeSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LikeSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LikeSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LikeSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LikeSchema).
func (m *LikeSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikeSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikeSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikeSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown LikeSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LikeSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikeSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikeSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown LikeSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikeSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikeSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikeSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LikeSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikeSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown LikeSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikeSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikeSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikeSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikeSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikeSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikeSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikeSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LikeSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikeSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LikeSchema edge %s", name)
}

// LocationSchemaMutation represents an operation that mutates the LocationSchema nodes in the graph.
type LocationSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LocationSchema, error)
	predicates    []predicate.LocationSchema
}

var _ ent.Mutation = (*LocationSchemaMutation)(nil)

// locationschemaOption allows management of the mutation configuration using functional options.
type locationschemaOption func(*LocationSchemaMutation)

// newLocationSchemaMutation creates new mutation for the LocationSchema entity.
func newLocationSchemaMutation(c config, op Op, opts ...locationschemaOption) *LocationSchemaMutation {
	m := &LocationSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeLocationSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationSchemaID sets the ID field of the mutation.
func withLocationSchemaID(id int) locationschemaOption {
	return func(m *LocationSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *LocationSchema
		)
		m.oldValue = func(ctx context.Context) (*LocationSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocationSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocationSchema sets the old LocationSchema of the mutation.
func withLocationSchema(node *LocationSchema) locationschemaOption {
	return func(m *LocationSchemaMutation) {
		m.oldValue = func(context.Context) (*LocationSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LocationSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the LocationSchemaMutation builder.
func (m *LocationSchemaMutation) Where(ps ...predicate.LocationSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LocationSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LocationSchema).
func (m *LocationSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown LocationSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LocationSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown LocationSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LocationSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown LocationSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LocationSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LocationSchema edge %s", name)
}

// LogoSchemaMutation represents an operation that mutates the LogoSchema nodes in the graph.
type LogoSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LogoSchema, error)
	predicates    []predicate.LogoSchema
}

var _ ent.Mutation = (*LogoSchemaMutation)(nil)

// logoschemaOption allows management of the mutation configuration using functional options.
type logoschemaOption func(*LogoSchemaMutation)

// newLogoSchemaMutation creates new mutation for the LogoSchema entity.
func newLogoSchemaMutation(c config, op Op, opts ...logoschemaOption) *LogoSchemaMutation {
	m := &LogoSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeLogoSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogoSchemaID sets the ID field of the mutation.
func withLogoSchemaID(id int) logoschemaOption {
	return func(m *LogoSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *LogoSchema
		)
		m.oldValue = func(ctx context.Context) (*LogoSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LogoSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogoSchema sets the old LogoSchema of the mutation.
func withLogoSchema(node *LogoSchema) logoschemaOption {
	return func(m *LogoSchemaMutation) {
		m.oldValue = func(context.Context) (*LogoSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogoSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogoSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogoSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogoSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LogoSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the LogoSchemaMutation builder.
func (m *LogoSchemaMutation) Where(ps ...predicate.LogoSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogoSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogoSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LogoSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogoSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogoSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LogoSchema).
func (m *LogoSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogoSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogoSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogoSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown LogoSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogoSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LogoSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogoSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogoSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogoSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown LogoSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogoSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogoSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogoSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LogoSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogoSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown LogoSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogoSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogoSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogoSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogoSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogoSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogoSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogoSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LogoSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogoSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LogoSchema edge %s", name)
}

// NamecardSchemaMutation represents an operation that mutates the NamecardSchema nodes in the graph.
type NamecardSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*NamecardSchema, error)
	predicates    []predicate.NamecardSchema
}

var _ ent.Mutation = (*NamecardSchemaMutation)(nil)

// namecardschemaOption allows management of the mutation configuration using functional options.
type namecardschemaOption func(*NamecardSchemaMutation)

// newNamecardSchemaMutation creates new mutation for the NamecardSchema entity.
func newNamecardSchemaMutation(c config, op Op, opts ...namecardschemaOption) *NamecardSchemaMutation {
	m := &NamecardSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeNamecardSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamecardSchemaID sets the ID field of the mutation.
func withNamecardSchemaID(id int) namecardschemaOption {
	return func(m *NamecardSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *NamecardSchema
		)
		m.oldValue = func(ctx context.Context) (*NamecardSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NamecardSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamecardSchema sets the old NamecardSchema of the mutation.
func withNamecardSchema(node *NamecardSchema) namecardschemaOption {
	return func(m *NamecardSchemaMutation) {
		m.oldValue = func(context.Context) (*NamecardSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamecardSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamecardSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamecardSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamecardSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NamecardSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user" edge to the UserSchema entity by id.
func (m *NamecardSchemaMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the UserSchema entity.
func (m *NamecardSchemaMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the UserSchema entity was cleared.
func (m *NamecardSchemaMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NamecardSchemaMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NamecardSchemaMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NamecardSchemaMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NamecardSchemaMutation builder.
func (m *NamecardSchemaMutation) Where(ps ...predicate.NamecardSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NamecardSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NamecardSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NamecardSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NamecardSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NamecardSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NamecardSchema).
func (m *NamecardSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamecardSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamecardSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamecardSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown NamecardSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamecardSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NamecardSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamecardSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamecardSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamecardSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown NamecardSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamecardSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamecardSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamecardSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NamecardSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamecardSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown NamecardSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamecardSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, namecardschema.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamecardSchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namecardschema.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamecardSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamecardSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamecardSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, namecardschema.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamecardSchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case namecardschema.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamecardSchemaMutation) ClearEdge(name string) error {
	switch name {
	case namecardschema.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NamecardSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamecardSchemaMutation) ResetEdge(name string) error {
	switch name {
	case namecardschema.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NamecardSchema edge %s", name)
}

// NotificationSchemaMutation represents an operation that mutates the NotificationSchema nodes in the graph.
type NotificationSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NotificationSchema, error)
	predicates    []predicate.NotificationSchema
}

var _ ent.Mutation = (*NotificationSchemaMutation)(nil)

// notificationschemaOption allows management of the mutation configuration using functional options.
type notificationschemaOption func(*NotificationSchemaMutation)

// newNotificationSchemaMutation creates new mutation for the NotificationSchema entity.
func newNotificationSchemaMutation(c config, op Op, opts ...notificationschemaOption) *NotificationSchemaMutation {
	m := &NotificationSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationSchemaID sets the ID field of the mutation.
func withNotificationSchemaID(id int) notificationschemaOption {
	return func(m *NotificationSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationSchema
		)
		m.oldValue = func(ctx context.Context) (*NotificationSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationSchema sets the old NotificationSchema of the mutation.
func withNotificationSchema(node *NotificationSchema) notificationschemaOption {
	return func(m *NotificationSchemaMutation) {
		m.oldValue = func(context.Context) (*NotificationSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the NotificationSchemaMutation builder.
func (m *NotificationSchemaMutation) Where(ps ...predicate.NotificationSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationSchema).
func (m *NotificationSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown NotificationSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown NotificationSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotificationSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown NotificationSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationSchema edge %s", name)
}

// PaymentSchemaMutation represents an operation that mutates the PaymentSchema nodes in the graph.
type PaymentSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PaymentSchema, error)
	predicates    []predicate.PaymentSchema
}

var _ ent.Mutation = (*PaymentSchemaMutation)(nil)

// paymentschemaOption allows management of the mutation configuration using functional options.
type paymentschemaOption func(*PaymentSchemaMutation)

// newPaymentSchemaMutation creates new mutation for the PaymentSchema entity.
func newPaymentSchemaMutation(c config, op Op, opts ...paymentschemaOption) *PaymentSchemaMutation {
	m := &PaymentSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentSchemaID sets the ID field of the mutation.
func withPaymentSchemaID(id int) paymentschemaOption {
	return func(m *PaymentSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentSchema
		)
		m.oldValue = func(ctx context.Context) (*PaymentSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentSchema sets the old PaymentSchema of the mutation.
func withPaymentSchema(node *PaymentSchema) paymentschemaOption {
	return func(m *PaymentSchemaMutation) {
		m.oldValue = func(context.Context) (*PaymentSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the PaymentSchemaMutation builder.
func (m *PaymentSchemaMutation) Where(ps ...predicate.PaymentSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentSchema).
func (m *PaymentSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PaymentSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PaymentSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PaymentSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentSchema edge %s", name)
}

// PersonalizationSchemaMutation represents an operation that mutates the PersonalizationSchema nodes in the graph.
type PersonalizationSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PersonalizationSchema, error)
	predicates    []predicate.PersonalizationSchema
}

var _ ent.Mutation = (*PersonalizationSchemaMutation)(nil)

// personalizationschemaOption allows management of the mutation configuration using functional options.
type personalizationschemaOption func(*PersonalizationSchemaMutation)

// newPersonalizationSchemaMutation creates new mutation for the PersonalizationSchema entity.
func newPersonalizationSchemaMutation(c config, op Op, opts ...personalizationschemaOption) *PersonalizationSchemaMutation {
	m := &PersonalizationSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalizationSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalizationSchemaID sets the ID field of the mutation.
func withPersonalizationSchemaID(id int) personalizationschemaOption {
	return func(m *PersonalizationSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalizationSchema
		)
		m.oldValue = func(ctx context.Context) (*PersonalizationSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalizationSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalizationSchema sets the old PersonalizationSchema of the mutation.
func withPersonalizationSchema(node *PersonalizationSchema) personalizationschemaOption {
	return func(m *PersonalizationSchemaMutation) {
		m.oldValue = func(context.Context) (*PersonalizationSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalizationSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalizationSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalizationSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalizationSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalizationSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user" edge to the UserSchema entity by id.
func (m *PersonalizationSchemaMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the UserSchema entity.
func (m *PersonalizationSchemaMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the UserSchema entity was cleared.
func (m *PersonalizationSchemaMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PersonalizationSchemaMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PersonalizationSchemaMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PersonalizationSchemaMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PersonalizationSchemaMutation builder.
func (m *PersonalizationSchemaMutation) Where(ps ...predicate.PersonalizationSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalizationSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalizationSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonalizationSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalizationSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalizationSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonalizationSchema).
func (m *PersonalizationSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalizationSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalizationSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalizationSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PersonalizationSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalizationSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonalizationSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalizationSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalizationSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalizationSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PersonalizationSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalizationSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalizationSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalizationSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PersonalizationSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalizationSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PersonalizationSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalizationSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, personalizationschema.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalizationSchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personalizationschema.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalizationSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalizationSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalizationSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, personalizationschema.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalizationSchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case personalizationschema.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalizationSchemaMutation) ClearEdge(name string) error {
	switch name {
	case personalizationschema.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PersonalizationSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalizationSchemaMutation) ResetEdge(name string) error {
	switch name {
	case personalizationschema.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PersonalizationSchema edge %s", name)
}

// PhoneSchemaMutation represents an operation that mutates the PhoneSchema nodes in the graph.
type PhoneSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PhoneSchema, error)
	predicates    []predicate.PhoneSchema
}

var _ ent.Mutation = (*PhoneSchemaMutation)(nil)

// phoneschemaOption allows management of the mutation configuration using functional options.
type phoneschemaOption func(*PhoneSchemaMutation)

// newPhoneSchemaMutation creates new mutation for the PhoneSchema entity.
func newPhoneSchemaMutation(c config, op Op, opts ...phoneschemaOption) *PhoneSchemaMutation {
	m := &PhoneSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypePhoneSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhoneSchemaID sets the ID field of the mutation.
func withPhoneSchemaID(id int) phoneschemaOption {
	return func(m *PhoneSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *PhoneSchema
		)
		m.oldValue = func(ctx context.Context) (*PhoneSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PhoneSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhoneSchema sets the old PhoneSchema of the mutation.
func withPhoneSchema(node *PhoneSchema) phoneschemaOption {
	return func(m *PhoneSchemaMutation) {
		m.oldValue = func(context.Context) (*PhoneSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhoneSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhoneSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PhoneSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PhoneSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PhoneSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwnerID sets the "owner" edge to the ProfileSchema entity by id.
func (m *PhoneSchemaMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the ProfileSchema entity.
func (m *PhoneSchemaMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the ProfileSchema entity was cleared.
func (m *PhoneSchemaMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PhoneSchemaMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PhoneSchemaMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PhoneSchemaMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PhoneSchemaMutation builder.
func (m *PhoneSchemaMutation) Where(ps ...predicate.PhoneSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PhoneSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PhoneSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PhoneSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PhoneSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PhoneSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PhoneSchema).
func (m *PhoneSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PhoneSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PhoneSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PhoneSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PhoneSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhoneSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PhoneSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PhoneSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PhoneSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhoneSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PhoneSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PhoneSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PhoneSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhoneSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PhoneSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PhoneSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PhoneSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PhoneSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, phoneschema.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PhoneSchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case phoneschema.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PhoneSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PhoneSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PhoneSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, phoneschema.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PhoneSchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case phoneschema.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PhoneSchemaMutation) ClearEdge(name string) error {
	switch name {
	case phoneschema.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PhoneSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PhoneSchemaMutation) ResetEdge(name string) error {
	switch name {
	case phoneschema.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PhoneSchema edge %s", name)
}

// PhotoSchemaMutation represents an operation that mutates the PhotoSchema nodes in the graph.
type PhotoSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PhotoSchema, error)
	predicates    []predicate.PhotoSchema
}

var _ ent.Mutation = (*PhotoSchemaMutation)(nil)

// photoschemaOption allows management of the mutation configuration using functional options.
type photoschemaOption func(*PhotoSchemaMutation)

// newPhotoSchemaMutation creates new mutation for the PhotoSchema entity.
func newPhotoSchemaMutation(c config, op Op, opts ...photoschemaOption) *PhotoSchemaMutation {
	m := &PhotoSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypePhotoSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhotoSchemaID sets the ID field of the mutation.
func withPhotoSchemaID(id int) photoschemaOption {
	return func(m *PhotoSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *PhotoSchema
		)
		m.oldValue = func(ctx context.Context) (*PhotoSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PhotoSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhotoSchema sets the old PhotoSchema of the mutation.
func withPhotoSchema(node *PhotoSchema) photoschemaOption {
	return func(m *PhotoSchemaMutation) {
		m.oldValue = func(context.Context) (*PhotoSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhotoSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhotoSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PhotoSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PhotoSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PhotoSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwnerID sets the "owner" edge to the ProfileSchema entity by id.
func (m *PhotoSchemaMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the ProfileSchema entity.
func (m *PhotoSchemaMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the ProfileSchema entity was cleared.
func (m *PhotoSchemaMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PhotoSchemaMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PhotoSchemaMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PhotoSchemaMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PhotoSchemaMutation builder.
func (m *PhotoSchemaMutation) Where(ps ...predicate.PhotoSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PhotoSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PhotoSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PhotoSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PhotoSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PhotoSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PhotoSchema).
func (m *PhotoSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PhotoSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PhotoSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PhotoSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PhotoSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhotoSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PhotoSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PhotoSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PhotoSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhotoSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PhotoSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PhotoSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PhotoSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhotoSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PhotoSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PhotoSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PhotoSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PhotoSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, photoschema.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PhotoSchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case photoschema.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PhotoSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PhotoSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PhotoSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, photoschema.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PhotoSchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case photoschema.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PhotoSchemaMutation) ClearEdge(name string) error {
	switch name {
	case photoschema.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PhotoSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PhotoSchemaMutation) ResetEdge(name string) error {
	switch name {
	case photoschema.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PhotoSchema edge %s", name)
}

// PoolSchemaMutation represents an operation that mutates the PoolSchema nodes in the graph.
type PoolSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PoolSchema, error)
	predicates    []predicate.PoolSchema
}

var _ ent.Mutation = (*PoolSchemaMutation)(nil)

// poolschemaOption allows management of the mutation configuration using functional options.
type poolschemaOption func(*PoolSchemaMutation)

// newPoolSchemaMutation creates new mutation for the PoolSchema entity.
func newPoolSchemaMutation(c config, op Op, opts ...poolschemaOption) *PoolSchemaMutation {
	m := &PoolSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypePoolSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPoolSchemaID sets the ID field of the mutation.
func withPoolSchemaID(id int) poolschemaOption {
	return func(m *PoolSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *PoolSchema
		)
		m.oldValue = func(ctx context.Context) (*PoolSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PoolSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPoolSchema sets the old PoolSchema of the mutation.
func withPoolSchema(node *PoolSchema) poolschemaOption {
	return func(m *PoolSchemaMutation) {
		m.oldValue = func(context.Context) (*PoolSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PoolSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PoolSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PoolSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PoolSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PoolSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the PoolSchemaMutation builder.
func (m *PoolSchemaMutation) Where(ps ...predicate.PoolSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PoolSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PoolSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PoolSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PoolSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PoolSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PoolSchema).
func (m *PoolSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PoolSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PoolSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PoolSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PoolSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoolSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PoolSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PoolSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PoolSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoolSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PoolSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PoolSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PoolSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PoolSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PoolSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PoolSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PoolSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PoolSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PoolSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PoolSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PoolSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PoolSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PoolSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PoolSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PoolSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PoolSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PoolSchema edge %s", name)
}

// PortfolioSchemaMutation represents an operation that mutates the PortfolioSchema nodes in the graph.
type PortfolioSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PortfolioSchema, error)
	predicates    []predicate.PortfolioSchema
}

var _ ent.Mutation = (*PortfolioSchemaMutation)(nil)

// portfolioschemaOption allows management of the mutation configuration using functional options.
type portfolioschemaOption func(*PortfolioSchemaMutation)

// newPortfolioSchemaMutation creates new mutation for the PortfolioSchema entity.
func newPortfolioSchemaMutation(c config, op Op, opts ...portfolioschemaOption) *PortfolioSchemaMutation {
	m := &PortfolioSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypePortfolioSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortfolioSchemaID sets the ID field of the mutation.
func withPortfolioSchemaID(id int) portfolioschemaOption {
	return func(m *PortfolioSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *PortfolioSchema
		)
		m.oldValue = func(ctx context.Context) (*PortfolioSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PortfolioSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortfolioSchema sets the old PortfolioSchema of the mutation.
func withPortfolioSchema(node *PortfolioSchema) portfolioschemaOption {
	return func(m *PortfolioSchemaMutation) {
		m.oldValue = func(context.Context) (*PortfolioSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortfolioSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortfolioSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortfolioSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortfolioSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PortfolioSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the PortfolioSchemaMutation builder.
func (m *PortfolioSchemaMutation) Where(ps ...predicate.PortfolioSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortfolioSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortfolioSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PortfolioSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortfolioSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortfolioSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PortfolioSchema).
func (m *PortfolioSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortfolioSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortfolioSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortfolioSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PortfolioSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PortfolioSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortfolioSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortfolioSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PortfolioSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortfolioSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortfolioSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortfolioSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PortfolioSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortfolioSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PortfolioSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortfolioSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortfolioSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortfolioSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortfolioSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortfolioSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortfolioSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortfolioSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PortfolioSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortfolioSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PortfolioSchema edge %s", name)
}

// PositionSchemaMutation represents an operation that mutates the PositionSchema nodes in the graph.
type PositionSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PositionSchema, error)
	predicates    []predicate.PositionSchema
}

var _ ent.Mutation = (*PositionSchemaMutation)(nil)

// positionschemaOption allows management of the mutation configuration using functional options.
type positionschemaOption func(*PositionSchemaMutation)

// newPositionSchemaMutation creates new mutation for the PositionSchema entity.
func newPositionSchemaMutation(c config, op Op, opts ...positionschemaOption) *PositionSchemaMutation {
	m := &PositionSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypePositionSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionSchemaID sets the ID field of the mutation.
func withPositionSchemaID(id int) positionschemaOption {
	return func(m *PositionSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *PositionSchema
		)
		m.oldValue = func(ctx context.Context) (*PositionSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PositionSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPositionSchema sets the old PositionSchema of the mutation.
func withPositionSchema(node *PositionSchema) positionschemaOption {
	return func(m *PositionSchemaMutation) {
		m.oldValue = func(context.Context) (*PositionSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PositionSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the PositionSchemaMutation builder.
func (m *PositionSchemaMutation) Where(ps ...predicate.PositionSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PositionSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PositionSchema).
func (m *PositionSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PositionSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PositionSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PositionSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PositionSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PositionSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PositionSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PositionSchema edge %s", name)
}

// ProfileSchemaMutation represents an operation that mutates the ProfileSchema nodes in the graph.
type ProfileSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	photo         *int
	clearedphoto  bool
	phone         *int
	clearedphone  bool
	done          bool
	oldValue      func(context.Context) (*ProfileSchema, error)
	predicates    []predicate.ProfileSchema
}

var _ ent.Mutation = (*ProfileSchemaMutation)(nil)

// profileschemaOption allows management of the mutation configuration using functional options.
type profileschemaOption func(*ProfileSchemaMutation)

// newProfileSchemaMutation creates new mutation for the ProfileSchema entity.
func newProfileSchemaMutation(c config, op Op, opts ...profileschemaOption) *ProfileSchemaMutation {
	m := &ProfileSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeProfileSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileSchemaID sets the ID field of the mutation.
func withProfileSchemaID(id int) profileschemaOption {
	return func(m *ProfileSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfileSchema
		)
		m.oldValue = func(ctx context.Context) (*ProfileSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfileSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfileSchema sets the old ProfileSchema of the mutation.
func withProfileSchema(node *ProfileSchema) profileschemaOption {
	return func(m *ProfileSchemaMutation) {
		m.oldValue = func(context.Context) (*ProfileSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfileSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwnerID sets the "owner" edge to the UserSchema entity by id.
func (m *ProfileSchemaMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the UserSchema entity.
func (m *ProfileSchemaMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the UserSchema entity was cleared.
func (m *ProfileSchemaMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ProfileSchemaMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ProfileSchemaMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ProfileSchemaMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetPhotoID sets the "photo" edge to the PhotoSchema entity by id.
func (m *ProfileSchemaMutation) SetPhotoID(id int) {
	m.photo = &id
}

// ClearPhoto clears the "photo" edge to the PhotoSchema entity.
func (m *ProfileSchemaMutation) ClearPhoto() {
	m.clearedphoto = true
}

// PhotoCleared reports if the "photo" edge to the PhotoSchema entity was cleared.
func (m *ProfileSchemaMutation) PhotoCleared() bool {
	return m.clearedphoto
}

// PhotoID returns the "photo" edge ID in the mutation.
func (m *ProfileSchemaMutation) PhotoID() (id int, exists bool) {
	if m.photo != nil {
		return *m.photo, true
	}
	return
}

// PhotoIDs returns the "photo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PhotoID instead. It exists only for internal usage by the builders.
func (m *ProfileSchemaMutation) PhotoIDs() (ids []int) {
	if id := m.photo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPhoto resets all changes to the "photo" edge.
func (m *ProfileSchemaMutation) ResetPhoto() {
	m.photo = nil
	m.clearedphoto = false
}

// SetPhoneID sets the "phone" edge to the PhoneSchema entity by id.
func (m *ProfileSchemaMutation) SetPhoneID(id int) {
	m.phone = &id
}

// ClearPhone clears the "phone" edge to the PhoneSchema entity.
func (m *ProfileSchemaMutation) ClearPhone() {
	m.clearedphone = true
}

// PhoneCleared reports if the "phone" edge to the PhoneSchema entity was cleared.
func (m *ProfileSchemaMutation) PhoneCleared() bool {
	return m.clearedphone
}

// PhoneID returns the "phone" edge ID in the mutation.
func (m *ProfileSchemaMutation) PhoneID() (id int, exists bool) {
	if m.phone != nil {
		return *m.phone, true
	}
	return
}

// PhoneIDs returns the "phone" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PhoneID instead. It exists only for internal usage by the builders.
func (m *ProfileSchemaMutation) PhoneIDs() (ids []int) {
	if id := m.phone; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPhone resets all changes to the "phone" edge.
func (m *ProfileSchemaMutation) ResetPhone() {
	m.phone = nil
	m.clearedphone = false
}

// Where appends a list predicates to the ProfileSchemaMutation builder.
func (m *ProfileSchemaMutation) Where(ps ...predicate.ProfileSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfileSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfileSchema).
func (m *ProfileSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ProfileSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProfileSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ProfileSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfileSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ProfileSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, profileschema.EdgeOwner)
	}
	if m.photo != nil {
		edges = append(edges, profileschema.EdgePhoto)
	}
	if m.phone != nil {
		edges = append(edges, profileschema.EdgePhone)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileSchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profileschema.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case profileschema.EdgePhoto:
		if id := m.photo; id != nil {
			return []ent.Value{*id}
		}
	case profileschema.EdgePhone:
		if id := m.phone; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, profileschema.EdgeOwner)
	}
	if m.clearedphoto {
		edges = append(edges, profileschema.EdgePhoto)
	}
	if m.clearedphone {
		edges = append(edges, profileschema.EdgePhone)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileSchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case profileschema.EdgeOwner:
		return m.clearedowner
	case profileschema.EdgePhoto:
		return m.clearedphoto
	case profileschema.EdgePhone:
		return m.clearedphone
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileSchemaMutation) ClearEdge(name string) error {
	switch name {
	case profileschema.EdgeOwner:
		m.ClearOwner()
		return nil
	case profileschema.EdgePhoto:
		m.ClearPhoto()
		return nil
	case profileschema.EdgePhone:
		m.ClearPhone()
		return nil
	}
	return fmt.Errorf("unknown ProfileSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileSchemaMutation) ResetEdge(name string) error {
	switch name {
	case profileschema.EdgeOwner:
		m.ResetOwner()
		return nil
	case profileschema.EdgePhoto:
		m.ResetPhoto()
		return nil
	case profileschema.EdgePhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown ProfileSchema edge %s", name)
}

// ReferrerSchemaMutation represents an operation that mutates the ReferrerSchema nodes in the graph.
type ReferrerSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ReferrerSchema, error)
	predicates    []predicate.ReferrerSchema
}

var _ ent.Mutation = (*ReferrerSchemaMutation)(nil)

// referrerschemaOption allows management of the mutation configuration using functional options.
type referrerschemaOption func(*ReferrerSchemaMutation)

// newReferrerSchemaMutation creates new mutation for the ReferrerSchema entity.
func newReferrerSchemaMutation(c config, op Op, opts ...referrerschemaOption) *ReferrerSchemaMutation {
	m := &ReferrerSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeReferrerSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReferrerSchemaID sets the ID field of the mutation.
func withReferrerSchemaID(id int) referrerschemaOption {
	return func(m *ReferrerSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *ReferrerSchema
		)
		m.oldValue = func(ctx context.Context) (*ReferrerSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReferrerSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReferrerSchema sets the old ReferrerSchema of the mutation.
func withReferrerSchema(node *ReferrerSchema) referrerschemaOption {
	return func(m *ReferrerSchemaMutation) {
		m.oldValue = func(context.Context) (*ReferrerSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReferrerSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReferrerSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReferrerSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReferrerSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReferrerSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user" edge to the UserSchema entity by id.
func (m *ReferrerSchemaMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the UserSchema entity.
func (m *ReferrerSchemaMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the UserSchema entity was cleared.
func (m *ReferrerSchemaMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ReferrerSchemaMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ReferrerSchemaMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReferrerSchemaMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ReferrerSchemaMutation builder.
func (m *ReferrerSchemaMutation) Where(ps ...predicate.ReferrerSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReferrerSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReferrerSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReferrerSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReferrerSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReferrerSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReferrerSchema).
func (m *ReferrerSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReferrerSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReferrerSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReferrerSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ReferrerSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferrerSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReferrerSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReferrerSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReferrerSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferrerSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ReferrerSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReferrerSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReferrerSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReferrerSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReferrerSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReferrerSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ReferrerSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReferrerSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, referrerschema.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReferrerSchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case referrerschema.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReferrerSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReferrerSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReferrerSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, referrerschema.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReferrerSchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case referrerschema.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReferrerSchemaMutation) ClearEdge(name string) error {
	switch name {
	case referrerschema.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ReferrerSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReferrerSchemaMutation) ResetEdge(name string) error {
	switch name {
	case referrerschema.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ReferrerSchema edge %s", name)
}

// ResumeSchemaMutation represents an operation that mutates the ResumeSchema nodes in the graph.
type ResumeSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ResumeSchema, error)
	predicates    []predicate.ResumeSchema
}

var _ ent.Mutation = (*ResumeSchemaMutation)(nil)

// resumeschemaOption allows management of the mutation configuration using functional options.
type resumeschemaOption func(*ResumeSchemaMutation)

// newResumeSchemaMutation creates new mutation for the ResumeSchema entity.
func newResumeSchemaMutation(c config, op Op, opts ...resumeschemaOption) *ResumeSchemaMutation {
	m := &ResumeSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeSchemaID sets the ID field of the mutation.
func withResumeSchemaID(id int) resumeschemaOption {
	return func(m *ResumeSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeSchema
		)
		m.oldValue = func(ctx context.Context) (*ResumeSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeSchema sets the old ResumeSchema of the mutation.
func withResumeSchema(node *ResumeSchema) resumeschemaOption {
	return func(m *ResumeSchemaMutation) {
		m.oldValue = func(context.Context) (*ResumeSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ResumeSchemaMutation builder.
func (m *ResumeSchemaMutation) Where(ps ...predicate.ResumeSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeSchema).
func (m *ResumeSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ResumeSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ResumeSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResumeSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ResumeSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ResumeSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ResumeSchema edge %s", name)
}

// RoleSchemaMutation represents an operation that mutates the RoleSchema nodes in the graph.
type RoleSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*RoleSchema, error)
	predicates    []predicate.RoleSchema
}

var _ ent.Mutation = (*RoleSchemaMutation)(nil)

// roleschemaOption allows management of the mutation configuration using functional options.
type roleschemaOption func(*RoleSchemaMutation)

// newRoleSchemaMutation creates new mutation for the RoleSchema entity.
func newRoleSchemaMutation(c config, op Op, opts ...roleschemaOption) *RoleSchemaMutation {
	m := &RoleSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleSchemaID sets the ID field of the mutation.
func withRoleSchemaID(id int) roleschemaOption {
	return func(m *RoleSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleSchema
		)
		m.oldValue = func(ctx context.Context) (*RoleSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleSchema sets the old RoleSchema of the mutation.
func withRoleSchema(node *RoleSchema) roleschemaOption {
	return func(m *RoleSchemaMutation) {
		m.oldValue = func(context.Context) (*RoleSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user" edge to the UserSchema entity by id.
func (m *RoleSchemaMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the UserSchema entity.
func (m *RoleSchemaMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the UserSchema entity was cleared.
func (m *RoleSchemaMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RoleSchemaMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RoleSchemaMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RoleSchemaMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the RoleSchemaMutation builder.
func (m *RoleSchemaMutation) Where(ps ...predicate.RoleSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleSchema).
func (m *RoleSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown RoleSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown RoleSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RoleSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown RoleSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, roleschema.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleSchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roleschema.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, roleschema.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleSchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case roleschema.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleSchemaMutation) ClearEdge(name string) error {
	switch name {
	case roleschema.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown RoleSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleSchemaMutation) ResetEdge(name string) error {
	switch name {
	case roleschema.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown RoleSchema edge %s", name)
}

// SkillSchemaMutation represents an operation that mutates the SkillSchema nodes in the graph.
type SkillSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SkillSchema, error)
	predicates    []predicate.SkillSchema
}

var _ ent.Mutation = (*SkillSchemaMutation)(nil)

// skillschemaOption allows management of the mutation configuration using functional options.
type skillschemaOption func(*SkillSchemaMutation)

// newSkillSchemaMutation creates new mutation for the SkillSchema entity.
func newSkillSchemaMutation(c config, op Op, opts ...skillschemaOption) *SkillSchemaMutation {
	m := &SkillSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeSkillSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillSchemaID sets the ID field of the mutation.
func withSkillSchemaID(id int) skillschemaOption {
	return func(m *SkillSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *SkillSchema
		)
		m.oldValue = func(ctx context.Context) (*SkillSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SkillSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkillSchema sets the old SkillSchema of the mutation.
func withSkillSchema(node *SkillSchema) skillschemaOption {
	return func(m *SkillSchemaMutation) {
		m.oldValue = func(context.Context) (*SkillSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SkillSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the SkillSchemaMutation builder.
func (m *SkillSchemaMutation) Where(ps ...predicate.SkillSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SkillSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SkillSchema).
func (m *SkillSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown SkillSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SkillSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown SkillSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SkillSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown SkillSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SkillSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SkillSchema edge %s", name)
}

// SubscribeSchemaMutation represents an operation that mutates the SubscribeSchema nodes in the graph.
type SubscribeSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SubscribeSchema, error)
	predicates    []predicate.SubscribeSchema
}

var _ ent.Mutation = (*SubscribeSchemaMutation)(nil)

// subscribeschemaOption allows management of the mutation configuration using functional options.
type subscribeschemaOption func(*SubscribeSchemaMutation)

// newSubscribeSchemaMutation creates new mutation for the SubscribeSchema entity.
func newSubscribeSchemaMutation(c config, op Op, opts ...subscribeschemaOption) *SubscribeSchemaMutation {
	m := &SubscribeSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribeSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribeSchemaID sets the ID field of the mutation.
func withSubscribeSchemaID(id int) subscribeschemaOption {
	return func(m *SubscribeSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscribeSchema
		)
		m.oldValue = func(ctx context.Context) (*SubscribeSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscribeSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribeSchema sets the old SubscribeSchema of the mutation.
func withSubscribeSchema(node *SubscribeSchema) subscribeschemaOption {
	return func(m *SubscribeSchemaMutation) {
		m.oldValue = func(context.Context) (*SubscribeSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribeSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribeSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribeSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribeSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscribeSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the SubscribeSchemaMutation builder.
func (m *SubscribeSchemaMutation) Where(ps ...predicate.SubscribeSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscribeSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscribeSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscribeSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscribeSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscribeSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscribeSchema).
func (m *SubscribeSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribeSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribeSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribeSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown SubscribeSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscribeSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribeSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribeSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown SubscribeSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribeSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribeSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribeSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubscribeSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribeSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown SubscribeSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribeSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribeSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribeSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribeSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribeSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribeSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribeSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SubscribeSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribeSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SubscribeSchema edge %s", name)
}

// ThreadSchemaMutation represents an operation that mutates the ThreadSchema nodes in the graph.
type ThreadSchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ThreadSchema, error)
	predicates    []predicate.ThreadSchema
}

var _ ent.Mutation = (*ThreadSchemaMutation)(nil)

// threadschemaOption allows management of the mutation configuration using functional options.
type threadschemaOption func(*ThreadSchemaMutation)

// newThreadSchemaMutation creates new mutation for the ThreadSchema entity.
func newThreadSchemaMutation(c config, op Op, opts ...threadschemaOption) *ThreadSchemaMutation {
	m := &ThreadSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadSchemaID sets the ID field of the mutation.
func withThreadSchemaID(id int) threadschemaOption {
	return func(m *ThreadSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadSchema
		)
		m.oldValue = func(ctx context.Context) (*ThreadSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadSchema sets the old ThreadSchema of the mutation.
func withThreadSchema(node *ThreadSchema) threadschemaOption {
	return func(m *ThreadSchemaMutation) {
		m.oldValue = func(context.Context) (*ThreadSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ThreadSchemaMutation builder.
func (m *ThreadSchemaMutation) Where(ps ...predicate.ThreadSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadSchema).
func (m *ThreadSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadSchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadSchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ThreadSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadSchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ThreadSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadSchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ThreadSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadSchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadSchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadSchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadSchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ThreadSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadSchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ThreadSchema edge %s", name)
}

// UserSchemaMutation represents an operation that mutates the UserSchema nodes in the graph.
type UserSchemaMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	uuid                   *uuid.UUID
	username               *string
	password               *string
	email                  *string
	createdAt              *time.Time
	updatedAt              *time.Time
	clearedFields          map[string]struct{}
	roles                  map[int]struct{}
	removedroles           map[int]struct{}
	clearedroles           bool
	profile                *int
	clearedprofile         bool
	follow                 *int
	clearedfollow          bool
	referrer               *int
	clearedreferrer        bool
	personalization        *int
	clearedpersonalization bool
	namecard               *int
	clearednamecard        bool
	done                   bool
	oldValue               func(context.Context) (*UserSchema, error)
	predicates             []predicate.UserSchema
}

var _ ent.Mutation = (*UserSchemaMutation)(nil)

// userschemaOption allows management of the mutation configuration using functional options.
type userschemaOption func(*UserSchemaMutation)

// newUserSchemaMutation creates new mutation for the UserSchema entity.
func newUserSchemaMutation(c config, op Op, opts ...userschemaOption) *UserSchemaMutation {
	m := &UserSchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSchemaID sets the ID field of the mutation.
func withUserSchemaID(id int) userschemaOption {
	return func(m *UserSchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSchema
		)
		m.oldValue = func(ctx context.Context) (*UserSchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSchema sets the old UserSchema of the mutation.
func withUserSchema(node *UserSchema) userschemaOption {
	return func(m *UserSchemaMutation) {
		m.oldValue = func(context.Context) (*UserSchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *UserSchemaMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserSchemaMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the UserSchema entity.
// If the UserSchema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSchemaMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserSchemaMutation) ResetUUID() {
	m.uuid = nil
}

// SetUsername sets the "username" field.
func (m *UserSchemaMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserSchemaMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the UserSchema entity.
// If the UserSchema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSchemaMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserSchemaMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserSchemaMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserSchemaMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserSchema entity.
// If the UserSchema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSchemaMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserSchemaMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserSchemaMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserSchemaMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserSchema entity.
// If the UserSchema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSchemaMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserSchemaMutation) ResetEmail() {
	m.email = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserSchemaMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserSchemaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserSchema entity.
// If the UserSchema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSchemaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserSchemaMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserSchemaMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserSchemaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserSchema entity.
// If the UserSchema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSchemaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserSchemaMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddRoleIDs adds the "roles" edge to the RoleSchema entity by ids.
func (m *UserSchemaMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the RoleSchema entity.
func (m *UserSchemaMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the RoleSchema entity was cleared.
func (m *UserSchemaMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the RoleSchema entity by IDs.
func (m *UserSchemaMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the RoleSchema entity.
func (m *UserSchemaMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserSchemaMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserSchemaMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// SetProfileID sets the "profile" edge to the ProfileSchema entity by id.
func (m *UserSchemaMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the ProfileSchema entity.
func (m *UserSchemaMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the ProfileSchema entity was cleared.
func (m *UserSchemaMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserSchemaMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserSchemaMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserSchemaMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetFollowID sets the "follow" edge to the FollowSchema entity by id.
func (m *UserSchemaMutation) SetFollowID(id int) {
	m.follow = &id
}

// ClearFollow clears the "follow" edge to the FollowSchema entity.
func (m *UserSchemaMutation) ClearFollow() {
	m.clearedfollow = true
}

// FollowCleared reports if the "follow" edge to the FollowSchema entity was cleared.
func (m *UserSchemaMutation) FollowCleared() bool {
	return m.clearedfollow
}

// FollowID returns the "follow" edge ID in the mutation.
func (m *UserSchemaMutation) FollowID() (id int, exists bool) {
	if m.follow != nil {
		return *m.follow, true
	}
	return
}

// FollowIDs returns the "follow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowID instead. It exists only for internal usage by the builders.
func (m *UserSchemaMutation) FollowIDs() (ids []int) {
	if id := m.follow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollow resets all changes to the "follow" edge.
func (m *UserSchemaMutation) ResetFollow() {
	m.follow = nil
	m.clearedfollow = false
}

// SetReferrerID sets the "referrer" edge to the ReferrerSchema entity by id.
func (m *UserSchemaMutation) SetReferrerID(id int) {
	m.referrer = &id
}

// ClearReferrer clears the "referrer" edge to the ReferrerSchema entity.
func (m *UserSchemaMutation) ClearReferrer() {
	m.clearedreferrer = true
}

// ReferrerCleared reports if the "referrer" edge to the ReferrerSchema entity was cleared.
func (m *UserSchemaMutation) ReferrerCleared() bool {
	return m.clearedreferrer
}

// ReferrerID returns the "referrer" edge ID in the mutation.
func (m *UserSchemaMutation) ReferrerID() (id int, exists bool) {
	if m.referrer != nil {
		return *m.referrer, true
	}
	return
}

// ReferrerIDs returns the "referrer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferrerID instead. It exists only for internal usage by the builders.
func (m *UserSchemaMutation) ReferrerIDs() (ids []int) {
	if id := m.referrer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferrer resets all changes to the "referrer" edge.
func (m *UserSchemaMutation) ResetReferrer() {
	m.referrer = nil
	m.clearedreferrer = false
}

// SetPersonalizationID sets the "personalization" edge to the PersonalizationSchema entity by id.
func (m *UserSchemaMutation) SetPersonalizationID(id int) {
	m.personalization = &id
}

// ClearPersonalization clears the "personalization" edge to the PersonalizationSchema entity.
func (m *UserSchemaMutation) ClearPersonalization() {
	m.clearedpersonalization = true
}

// PersonalizationCleared reports if the "personalization" edge to the PersonalizationSchema entity was cleared.
func (m *UserSchemaMutation) PersonalizationCleared() bool {
	return m.clearedpersonalization
}

// PersonalizationID returns the "personalization" edge ID in the mutation.
func (m *UserSchemaMutation) PersonalizationID() (id int, exists bool) {
	if m.personalization != nil {
		return *m.personalization, true
	}
	return
}

// PersonalizationIDs returns the "personalization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonalizationID instead. It exists only for internal usage by the builders.
func (m *UserSchemaMutation) PersonalizationIDs() (ids []int) {
	if id := m.personalization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersonalization resets all changes to the "personalization" edge.
func (m *UserSchemaMutation) ResetPersonalization() {
	m.personalization = nil
	m.clearedpersonalization = false
}

// SetNamecardID sets the "namecard" edge to the NamecardSchema entity by id.
func (m *UserSchemaMutation) SetNamecardID(id int) {
	m.namecard = &id
}

// ClearNamecard clears the "namecard" edge to the NamecardSchema entity.
func (m *UserSchemaMutation) ClearNamecard() {
	m.clearednamecard = true
}

// NamecardCleared reports if the "namecard" edge to the NamecardSchema entity was cleared.
func (m *UserSchemaMutation) NamecardCleared() bool {
	return m.clearednamecard
}

// NamecardID returns the "namecard" edge ID in the mutation.
func (m *UserSchemaMutation) NamecardID() (id int, exists bool) {
	if m.namecard != nil {
		return *m.namecard, true
	}
	return
}

// NamecardIDs returns the "namecard" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamecardID instead. It exists only for internal usage by the builders.
func (m *UserSchemaMutation) NamecardIDs() (ids []int) {
	if id := m.namecard; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamecard resets all changes to the "namecard" edge.
func (m *UserSchemaMutation) ResetNamecard() {
	m.namecard = nil
	m.clearednamecard = false
}

// Where appends a list predicates to the UserSchemaMutation builder.
func (m *UserSchemaMutation) Where(ps ...predicate.UserSchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSchema).
func (m *UserSchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSchemaMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, userschema.FieldUUID)
	}
	if m.username != nil {
		fields = append(fields, userschema.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, userschema.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, userschema.FieldEmail)
	}
	if m.createdAt != nil {
		fields = append(fields, userschema.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, userschema.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSchemaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userschema.FieldUUID:
		return m.UUID()
	case userschema.FieldUsername:
		return m.Username()
	case userschema.FieldPassword:
		return m.Password()
	case userschema.FieldEmail:
		return m.Email()
	case userschema.FieldCreatedAt:
		return m.CreatedAt()
	case userschema.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userschema.FieldUUID:
		return m.OldUUID(ctx)
	case userschema.FieldUsername:
		return m.OldUsername(ctx)
	case userschema.FieldPassword:
		return m.OldPassword(ctx)
	case userschema.FieldEmail:
		return m.OldEmail(ctx)
	case userschema.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userschema.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserSchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userschema.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case userschema.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case userschema.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case userschema.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case userschema.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userschema.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserSchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSchemaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSchemaMutation) ResetField(name string) error {
	switch name {
	case userschema.FieldUUID:
		m.ResetUUID()
		return nil
	case userschema.FieldUsername:
		m.ResetUsername()
		return nil
	case userschema.FieldPassword:
		m.ResetPassword()
		return nil
	case userschema.FieldEmail:
		m.ResetEmail()
		return nil
	case userschema.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userschema.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.roles != nil {
		edges = append(edges, userschema.EdgeRoles)
	}
	if m.profile != nil {
		edges = append(edges, userschema.EdgeProfile)
	}
	if m.follow != nil {
		edges = append(edges, userschema.EdgeFollow)
	}
	if m.referrer != nil {
		edges = append(edges, userschema.EdgeReferrer)
	}
	if m.personalization != nil {
		edges = append(edges, userschema.EdgePersonalization)
	}
	if m.namecard != nil {
		edges = append(edges, userschema.EdgeNamecard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userschema.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case userschema.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case userschema.EdgeFollow:
		if id := m.follow; id != nil {
			return []ent.Value{*id}
		}
	case userschema.EdgeReferrer:
		if id := m.referrer; id != nil {
			return []ent.Value{*id}
		}
	case userschema.EdgePersonalization:
		if id := m.personalization; id != nil {
			return []ent.Value{*id}
		}
	case userschema.EdgeNamecard:
		if id := m.namecard; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedroles != nil {
		edges = append(edges, userschema.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSchemaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userschema.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedroles {
		edges = append(edges, userschema.EdgeRoles)
	}
	if m.clearedprofile {
		edges = append(edges, userschema.EdgeProfile)
	}
	if m.clearedfollow {
		edges = append(edges, userschema.EdgeFollow)
	}
	if m.clearedreferrer {
		edges = append(edges, userschema.EdgeReferrer)
	}
	if m.clearedpersonalization {
		edges = append(edges, userschema.EdgePersonalization)
	}
	if m.clearednamecard {
		edges = append(edges, userschema.EdgeNamecard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case userschema.EdgeRoles:
		return m.clearedroles
	case userschema.EdgeProfile:
		return m.clearedprofile
	case userschema.EdgeFollow:
		return m.clearedfollow
	case userschema.EdgeReferrer:
		return m.clearedreferrer
	case userschema.EdgePersonalization:
		return m.clearedpersonalization
	case userschema.EdgeNamecard:
		return m.clearednamecard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSchemaMutation) ClearEdge(name string) error {
	switch name {
	case userschema.EdgeProfile:
		m.ClearProfile()
		return nil
	case userschema.EdgeFollow:
		m.ClearFollow()
		return nil
	case userschema.EdgeReferrer:
		m.ClearReferrer()
		return nil
	case userschema.EdgePersonalization:
		m.ClearPersonalization()
		return nil
	case userschema.EdgeNamecard:
		m.ClearNamecard()
		return nil
	}
	return fmt.Errorf("unknown UserSchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSchemaMutation) ResetEdge(name string) error {
	switch name {
	case userschema.EdgeRoles:
		m.ResetRoles()
		return nil
	case userschema.EdgeProfile:
		m.ResetProfile()
		return nil
	case userschema.EdgeFollow:
		m.ResetFollow()
		return nil
	case userschema.EdgeReferrer:
		m.ResetReferrer()
		return nil
	case userschema.EdgePersonalization:
		m.ResetPersonalization()
		return nil
	case userschema.EdgeNamecard:
		m.ResetNamecard()
		return nil
	}
	return fmt.Errorf("unknown UserSchema edge %s", name)
}
